<html><head> <style>
:root {
  --color-primary: 216, 83%, 45%;
  --color-secondary: 215, 49%, 87%;
  --color-neutral-0: 0, 0%, 100%;
  --color-neutral-1: 204, 33%, 97%;
  --color-neutral-2: 213, 30%, 85%;
  --color-invert-0: 0, 0%, 0%;
  --color-invert-1: 205, 84%, 10%;
  --color-invert-2: 206, 20%, 46%;
  --color-invert-3: 205, 20%, 70%;
  /* Font sizes */
  --text-size-x-small: 1.1rem;
  --text-size-small: 1.2rem;
  --text-size-medium: 1.4rem;
  --text-size-large: 1.6rem;
  --text-size-x-large: 1.8rem;
  /* Font weights */
  --text-weight-normal: 400;
  --text-weight-bold: 600;
  /* Line height */
  --line-height-small: 1.6rem;
  --line-height-medium: 2rem;
  --line-height-large: 2.4rem;
  /* SPACING + SIZING */
  /* Positive spacing */
  --size-xxx-small: 0.4rem;
  --size-xx-small: 0.8rem;
  --size-x-small: 1.6rem;
  --size-small: 2rem;
  --size-medium: 2.4rem;
  --size-x-large: 4.8rem;
  /* Negative spacing */
  --negative-size-xxx-small: calc(var(--size-xxx-small) * -1);
  --negative-size-xx-small: calc(var(--size-xx-small) * -1);
  --negative-size-x-small: calc(var(--size-x-small) * -1);
  --negative-size-small: calc(var(--size-small) * -1);
  --negative-size-medium: calc(var(--size-medium) * -1);
  --negative-size-x-large: calc(var(--size-x-large) * -1);
  /* BORDER RADIUS */
  --border-radius-small: 0.2rem;
  --border-radius-medium: 0.5rem;
  --border-radius-large: 0.6rem;
  /* TRANSFORMS */
  --translate: -50%, -50%;
  --rotate: 0deg;
  --scale: 1;
  /* TRANSITIONS */
  --transition-x-fast: 0.1s;
  --transition-fast: 0.2s;
  --transition-medium: 0.3s;
  --transition-slow: 0.4s;
  --transition-x-slow: 0.5s;
}

/* Basics */
*,
*:before,
*:after {
  margin: 0;
  padding: 0;
  box-sizing: inherit;
  font-family: inherit;
  font-weight: inherit;
  font-size: inherit;
  text-rendering: inherit;
}

html {
  box-sizing: border-box;
  font-family: "Inter", sans-serif;
  font-size: 62.5%;
  text-rendering: geometricPrecision;
  font-feature-settings: "tnum" on, "lnum" on, "cv02" on, "cv03" on, "cv04" on, "cv05" on, "cv07" on, "cv08" on, "cv09" on, "cv10" on, "cv06" on;
}

body {
  font-size: var(--text-size-medium);
  font-weight: var(--text-weight-normal);
  line-height: var(--line-height-medium);
  color: hsl(var(--color-invert-0));
  background: hsl(var(--color-neutral-1));
}

/* Svg */
svg {
  width: inherit;
  height: inherit;
  fill: inherit;
}

/*  Fonts */
@font-face {
  font-family: "Inter";
  font-style: normal;
  font-weight: 400;
  font-display: swap;
  src: url("https://rsms.me/inter/font-files/Inter-Regular.woff2?3.13") format("woff2"), url("https://rsms.me/inter/font-files/Inter-Regular.woff?3.13") format("woff");
}
@font-face {
  font-family: "Inter";
  font-style: normal;
  font-weight: 600;
  font-display: swap;
  src: url("https://rsms.me/inter/font-files/Inter-SemiBold.woff2?3.13") format("woff2"), url("https://rsms.me/inter/font-files/Inter-SemiBold.woff?3.13") format("woff");
}
/* Text utilities */
h1,
.h1 {
  line-height: var(--line-height-large);
  font-size: var(--text-size-x-large);
  font-weight: var(--text-weight-bold);
  margin: var(--size-xxx-small) 0;
  color: hsl(var(--color-invert-1));
}

h3,
.h3 {
  font-size: var(--text-size-large);
  line-height: var(--line-height-large);
  font-weight: var(--text-weight-bold);
  margin: var(--size-xx-small) 0;
  color: hsl(var(--color-invert-1));
}

h3,
.h3 {
  line-height: var(--line-height-large);
  font-size: var(--text-size-medium);
  font-weight: var(--text-weight-bold);
  margin: var(--size-xx-small) 0;
  color: hsl(var(--color-invert-1));
}

.small {
  line-height: var(--line-height-small);
  font-size: var(--text-size-small);
  font-weight: var(--text-weight-normal);
  color: hsl(var(--color-invert-3));
}

.caption {
  line-height: var(--line-height-small);
  font-size: var(--text-size-x-small);
  font-weight: var(--text-weight-normal);
  margin: 0;
  color: hsl(var(--color-invert-3));
  letter-spacing: 0.08em;
  text-transform: uppercase;
}

main.svelte-1apueeo.svelte-1apueeo {
  margin-bottom: 4.8rem;
}

main.svelte-1apueeo > div.svelte-1apueeo {
  padding: 0 var(--size-x-small);
  margin: 1.6rem 0;
}

footer.svelte-1apueeo.svelte-1apueeo {
  display: flex;
  position: fixed;
  bottom: 0;
  left: 0;
  right: 0;
  background: hsl(var(--color-neutral-0));
  box-shadow: 0px 0px 1.6rem hsla(var(--color-invert-0), 0.05);
  padding: 0.4rem 1.2rem;
}

footer.svelte-1apueeo .col {
  flex: 1 1 auto;
  margin: 0.4rem;
}

.helper.svelte-1apueeo.svelte-1apueeo {
  display: flex;
  color: hsl(var(--color-invert-3));
}

.helper.svelte-1apueeo .icon-container {
  flex: 0 0 2.4rem;
  height: auto;
  padding: 0.2rem;
}

.helper.svelte-1apueeo span.svelte-1apueeo {
  margin: 0.2rem 0.8rem;
}

label.svelte-19u47n0.svelte-19u47n0 {
  display: flex;
  margin: var(--size-xx-small) 0;
  color: hsl(var(--color-invert-2));
}

input.svelte-19u47n0.svelte-19u47n0 {
  position: absolute;
  width: var(--size-small);
  height: var(--size-small);
  z-index: -1;
  opacity: 0;
}

input.svelte-19u47n0.svelte-19u47n0:focus {
  outline: 0;
}

.checkbox-toggle.svelte-19u47n0.svelte-19u47n0 {
  position: relative;
  flex: 0 0 var(--size-medium);
  height: var(--size-medium);
}

.checkbox-toggle.svelte-19u47n0.svelte-19u47n0:before, .checkbox-toggle.svelte-19u47n0.svelte-19u47n0:after {
  background: hsl(var(--color-neutral-0));
  border: 1px solid hsl(var(--color-neutral-2));
  display: inline-block;
  position: absolute;
  left: 50%;
  top: 50%;
  content: "";
  width: 1.8rem;
  height: 1.8rem;
  opacity: 1;
  border-radius: var(--border-radius-small);
  transition: all var(--transition-fast) ease-out;
  filter: brightness(100%);
  transform-origin: center center;
  transform: translate(var(--translate)) rotate(var(--rotate)) scale(var(--scale));
}

.checkbox-toggle.svelte-19u47n0.svelte-19u47n0:before {
  z-index: -2;
}

.checkbox-toggle.svelte-19u47n0.svelte-19u47n0:after {
  z-index: -1;
}

label.svelte-19u47n0:hover .checkbox-toggle.svelte-19u47n0:after {
  filter: brightness(80%);
}

input.svelte-19u47n0:checked ~ .checkbox-toggle.svelte-19u47n0:after, input.svelte-19u47n0:checked ~ .checkbox-toggle.svelte-19u47n0:before {
  background: hsl(var(--color-primary));
  border-color: hsl(var(--color-primary));
}

input.svelte-19u47n0:checked ~ .checkbox-toggle.svelte-19u47n0:before {
  opacity: 0;
  --scale:1.75;
}

.checkbox-icon.svelte-19u47n0.svelte-19u47n0 {
  display: inline-block;
  width: 100%;
  height: 100%;
  transform: scale(0);
  color: hsl(var(--color-invert-1));
  transition: transform var(--transition-fast) ease-out;
}

input:checked ~ .checkbox-toggle.svelte-19u47n0 .checkbox-icon.svelte-19u47n0 {
  transform: scale(1);
  opacity: 1;
}

.label.svelte-19u47n0.svelte-19u47n0 {
  display: inline-flex;
  flex: 1 1 auto;
  margin: 0.2rem 0.8rem;
  justify-content: space-between;
}

.helper.svelte-19u47n0.svelte-19u47n0 {
  font-size: var(--text-size-small);
  font-weight: var(--text-weight-normal);
  margin: 0;
  line-height: var(--line-height-large);
  color: hsl(var(--color-invert-2));
}

.checkbox-icon.svelte-19u47n0 .icon-color {
  color: hsl(var(--color-neutral-0));
}

input.svelte-19u47n0:focus ~ .checkbox-toggle.svelte-19u47n0::after {
  box-shadow: 0 0 0 0.2rem hsl(var(--color-invert-0));
}

.icon-helper.svelte-19u47n0.svelte-19u47n0 {
  flex-shrink: 0;
  display: none;
  width: 2rem;
  height: 2rem;
  margin: 0 -0.8rem;
  color: hsl(var(--color-invert-3));
}

.icon-helper.show.svelte-19u47n0.svelte-19u47n0 {
  display: block;
}

.helper.svelte-19u47n0.svelte-19u47n0:empty {
  display: none;
}

label.svelte-1xs2am0.svelte-1xs2am0 {
  display: flex;
  justify-content: space-between;
  background: transparent;
  border: 1px solid hsl(var(--color-neutral-2));
  border-radius: var(--border-radius-small);
  overflow: hidden;
  font-size: var(--text-size-medium);
  font-weight: var(--text-weight-normal);
  line-height: var(--line-height-medium);
  color: hsl(var(--color-invert-2));
  transition: all var(--transition-fast) ease-out;
  margin: var(--size-xx-small) 0;
}

label.svelte-1xs2am0.svelte-1xs2am0:focus-within {
  box-shadow: 0 0 0 0.2rem hsl(var(--color-invert-0));
}

label.svelte-1xs2am0:focus-within .left-side.svelte-1xs2am0 {
  color: hsl(var(--color-invert-0));
}

.left-side.svelte-1xs2am0.svelte-1xs2am0 {
  flex: 1 1 auto;
  padding: 0.2rem;
  display: inherit;
  color: hsl(var(--color-invert-2));
}

.left-side.svelte-1xs2am0 .icon-container.svelte-1xs2am0 {
  display: inline-block;
  width: var(--size-small);
  height: var(--size-small);
  margin: 0.3rem;
  flex-shrink: 0;
  color: inherit;
}

.left-side.svelte-1xs2am0 .label.svelte-1xs2am0 {
  margin: 0.3rem;
}

.right-side.svelte-1xs2am0.svelte-1xs2am0 {
  display: inline-flex;
  background: hsl(var(--color-neutral-0));
  outline: 1px solid hsl(var(--color-neutral-2));
  flex: 0 0 35%;
  padding: 0.2rem 0.9rem;
}

.right-side.svelte-1xs2am0 input.svelte-1xs2am0 {
  background: transparent;
  border: transparent;
  width: 100%;
  text-align: right;
  line-height: inherit;
  font-weight: var(--text-weight-bold);
  margin: 0.3rem;
}

.right-side.svelte-1xs2am0 input.svelte-1xs2am0:focus {
  outline: transparent;
}

.right-side.svelte-1xs2am0 .unit-measure.svelte-1xs2am0 {
  margin: 0.3rem;
  color: hsl(var(--color-invert-3));
}

input.svelte-1xs2am0.svelte-1xs2am0::-webkit-inner-spin-button, input.svelte-1xs2am0.svelte-1xs2am0::-webkit-outer-spin-button {
  -webkit-appearance: none;
  margin: 0;
}

input.svelte-1xs2am0.svelte-1xs2am0 {
  -moz-appearance: textfield;
}

.unit-measure.svelte-1xs2am0.svelte-1xs2am0:empty {
  display: none;
}

.svg-icon.svelte-4kflf7 {
  color: inherit;
  display: block;
  width: 100%;
  height: 100%;
}

.svg-icon * {
  fill: currentColor;
}

button.svelte-hodw9t {
  display: inline-flex;
  justify-content: center;
  align-content: center;
  position: relative;
  font-size: var(--text-size-medium);
  line-height: var(--line-height-large);
  margin: 0;
  min-width: 8rem;
  padding: 0.3rem 1.2rem;
  border-radius: var(--border-radius-small);
  transition: background var(--transition-fast) ease-in;
}

button.svelte-hodw9t:focus {
  box-shadow: 0 0 0 0.2rem hsl(var(--color-invert-1));
  outline: 0;
}

.primary.svelte-hodw9t {
  background: hsl(var(--color-primary));
  color: hsl(var(--color-neutral-0));
  border: 1px solid hsl(var(--color-primary));
}

.secondary.svelte-hodw9t {
  background: transparent;
  color: hsl(var(--color-primary));
  border: 1px solid hsl(var(--color-neutral-2));
}
</style>
</head>
  <body>

<script type="text/javascript">
(function () {
    'use strict';

    const defaultSettings = {
        addPrevToDescription: true,
        framesPerSection: 6,
        textsPerSection: 8,
        notificationTimeout: 6000,
        updateUsingLocalStyles: false,
        partialMatch: false,
        fillerPrefix: '',
        fillerSuffix: '',
        strokeerPrefix: '',
        strokeerSuffix: '-stroke',
        effecterPrefix: '',
        effecterSuffix: '',
        griderPrefix: '',
        griderSuffix: '',
        texterPrefix: '',
        texterSuffix: '',
    };

    const CMD = figma.command;
    const counter = {
        applied: 0,
        created: 0,
        customize: 0,
        detached: 0,
        extracted: 0,
        generated: 0,
        textContainer: 0,
        miscContainer: 0,
        ignored: 0,
        renamed: 0,
        removed: 0,
        updated: 0,
    };
    const white = [255, 255, 255, 1];
    const black = [0, 0, 0, 1];
    const transparent = [0, 0, 0, 0];
    const colors = { white, black, transparent };

    const ucFirst = (word) => word[0].toLocaleUpperCase() + word.slice(1).toLocaleLowerCase();
    const addAffixTo = (word, prefix = '', suffix = '') => prefix + word + suffix;
    const isArrayEmpty = (array) => (array || []).length === 0;
    const groupBy = (array, key) => {
        return array.reduce((result, currentValue) => {
            (result[currentValue[key]] = result[currentValue[key]] || []).push(currentValue);
            return result;
        }, {});
    };
    function clone(val) {
        const type = typeof val;
        if (type === 'undefined' ||
            type === 'number' ||
            type === 'string' ||
            type === 'boolean' ||
            type === 'symbol' ||
            val === null) {
            return val;
        }
        else if (type === 'object') {
            if (val instanceof Array) {
                return val.map(clone);
            }
            else if (val instanceof Uint8Array) {
                return new Uint8Array(val);
            }
            else {
                const o = {};
                for (const key in val) {
                    o[key] = clone(val[key]);
                }
                return o;
            }
        }
        throw 'unknown';
    }
    const checkStyleType = (style, config) => {
        let styleType = style.type;
        if (style.type === 'PAINT') {
            styleType = 'FILL';
            const { filler, strokeer } = config;
            [filler, strokeer].map((styler) => {
                if ((styler.prefix !== '' || styler.suffix !== '') && styler.checkAffix(style)) {
                    styleType = styler.layerPropType;
                }
            });
        }
        return styleType;
    };
    const getFlat = ({ id, children = [] }) => {
        return children.reduce((r, o) => [...r, ...getFlat(o)], [id]);
    };

    class Styler {
        constructor(options = {}) {
            this.applyStyle = (layer, style) => {
                if (!style || layer[this.layerStyleID] === undefined || layer[this.layerStyleID] === style.id) {
                    console.log(`Apply: ${this.layerStyleID} not found || No style found for ${layer.name}`);
                    return;
                }
                layer[this.layerStyleID] = style.id;
                counter.applied++;
            };
            this.createStyle = (layer, addPrevToDescription) => {
                let newStyle = figma[this.createStyleCommand]();
                this.renameStyle(layer, newStyle);
                this.updateStyle(layer, newStyle, addPrevToDescription);
                return newStyle;
            };
            this.changeStyleDescription = (styleNameMatch, styleIdMatch) => {
                const currentDescription = styleNameMatch.description || '';
                const keyword = 'Previous style:';
                const pos = currentDescription.lastIndexOf(keyword);
                const newDescription = currentDescription.slice(0, pos) + `${keyword}\n${(styleIdMatch === null || styleIdMatch === void 0 ? void 0 : styleIdMatch.name) || ''}`;
                return !styleIdMatch
                    ? (styleNameMatch.description = currentDescription)
                    : (styleNameMatch.description = newDescription);
            };
            this.detachStyle = (layer) => {
                if (!layer[this.layerStyleID]) {
                    console.log(`Detach: ${this.layerPropType} not found.`);
                    return;
                }
                layer[this.layerStyleID] = '';
                counter.detached++;
            };
            this.getLocalStyles = () => figma[this.getLocalStylesCommand]();
            this.getStyleById = (layer) => figma.getStyleById(layer[this.layerStyleID]);
            this.getLocalStyleByByExternalId = (layer) => {
                var _a;
                const externalStyleName = ((_a = this.getStyleById(layer)) === null || _a === void 0 ? void 0 : _a.name) || '';
                return this.getLocalStyles().find((style) => style.name === externalStyleName);
            };
            this.getStyleByName = (name, partialMatch = defaultSettings.partialMatch) => {
                const stylesByType = this.getLocalStyles();
                const match = stylesByType.find((style) => style.name === addAffixTo(name, this.prefix, this.suffix));
                if (match) {
                    return match;
                }
                if (partialMatch === true) {
                    return stylesByType.find((style) => name.split(/\W+/g).find((word) => style.name.includes(word)));
                }
            };
            this.renameStyle = (layer, style) => {
                if (!style) {
                    console.log(`Rename: No style found for ${layer.name}`);
                    return;
                }
                style.name = addAffixTo(layer.name, this.prefix, this.suffix);
            };
            this.updateStyle = (layer, styleNameMatch, addPrevToDescription, styleIdMatch = null) => {
                if (addPrevToDescription) {
                    this.changeStyleDescription(styleNameMatch, styleIdMatch);
                }
                this.detachStyle(layer);
                this.styleProps.map((prop, propIndex) => {
                    if (!styleNameMatch || this.isPropEmpty(layer)) {
                        console.log(`Update: ${this.layerProps[propIndex]} not found || No style found for ${layer.name}`);
                        return;
                    }
                    styleNameMatch[prop] = layer[this.layerProps[propIndex]];
                });
                this.applyStyle(layer, styleNameMatch);
            };
            this.removeStyle = (layer, style) => {
                if (!style || style.remote === true) {
                    return;
                }
                const cmdType = CMD.split('-')[1];
                if (cmdType === this.layerPropType.toLocaleLowerCase() || cmdType === 'all') {
                    this.detachStyle(layer);
                    style.remove();
                    counter.removed++;
                }
            };
            this.generateStyle = (layer, options) => {
                const { styleIdMatch, styleNameMatch, updateUsingLocalStyles = defaultSettings.updateUsingLocalStyles, addPrevToDescription = defaultSettings.addPrevToDescription, } = options;
                if (this.isPropEmpty(layer) || this.isPropMixed(layer)) {
                    console.log(`Generate: We have some mixed or empty props.`);
                    return;
                }
                if ((!styleIdMatch || (styleIdMatch === null || styleIdMatch === void 0 ? void 0 : styleIdMatch.remote)) && !styleNameMatch) {
                    this.createStyle(layer, addPrevToDescription);
                    counter.created++;
                }
                else if ((!styleIdMatch || (styleIdMatch === null || styleIdMatch === void 0 ? void 0 : styleIdMatch.remote)) &&
                    styleNameMatch &&
                    updateUsingLocalStyles === false) {
                    this.updateStyle(layer, styleNameMatch, addPrevToDescription, styleIdMatch);
                    counter.updated++;
                }
                else if (styleIdMatch !== styleNameMatch && updateUsingLocalStyles === false) {
                    this.renameStyle(layer, styleIdMatch);
                    counter.renamed++;
                }
                else if (styleIdMatch &&
                    !(styleIdMatch === null || styleIdMatch === void 0 ? void 0 : styleIdMatch.remote) &&
                    !styleNameMatch &&
                    updateUsingLocalStyles === true) {
                    this.renameStyle(layer, styleIdMatch);
                    counter.renamed++;
                }
                else if (styleIdMatch !== styleNameMatch && updateUsingLocalStyles === true) {
                    this.updateStyle(layer, styleNameMatch, addPrevToDescription, styleIdMatch);
                    counter.updated++;
                }
                else {
                    counter.ignored++;
                }
                counter.generated++;
            };
            this.isPropEmpty = (layer) => isArrayEmpty(layer[this.layerProps[0]]);
            this.isPropMixed = (layer) => this.layerProps.some((prop) => layer[prop] === figma.mixed);
            this.checkAffix = (style) => {
                return style.name.startsWith(this.prefix) && style.name.endsWith(this.suffix);
            };
            this.replacePrefix = (name, newPrefix = '') => {
                return name.startsWith(this.prefix) ? newPrefix + name.slice(this.prefix.length) : name;
            };
            this.replaceSuffix = (name, newSuffix = '') => {
                return name.endsWith(this.suffix)
                    ? name.slice(0, name.lastIndexOf(this.suffix)) + newSuffix
                    : name;
            };
            this.replaceAffix = (name, newPrefix = '', newSuffix = newPrefix) => {
                name = this.replacePrefix(name, newPrefix);
                name = this.replaceSuffix(name, newSuffix);
                return name;
            };
            const { name = 'styler', styleType = '', layerPropType = styleType, prefix = '', suffix = '', styleProps, layerProps, } = options;
            this.name = name;
            this.styleType = styleType.toLocaleUpperCase();
            this.styleProps = styleProps || layerProps;
            this.layerProps = layerProps || styleProps;
            this.layerPropType = layerPropType.toLocaleUpperCase();
            this.layerStyleID = addAffixTo(layerPropType.toLocaleLowerCase(), '', 'StyleId');
            this.prefix = prefix;
            this.suffix = suffix;
            this.createStyleCommand = addAffixTo(ucFirst(styleType), 'create', 'Style');
            this.getLocalStylesCommand = addAffixTo(ucFirst(styleType), 'getLocal', 'Styles');
        }
    }

    const clientStorageKey = 'cachedSettings';
    class Config {
        constructor(options = defaultSettings) {
            const { addPrevToDescription = defaultSettings.addPrevToDescription, framesPerSection = defaultSettings.framesPerSection, textsPerSection = defaultSettings.textsPerSection, notificationTimeout = defaultSettings.notificationTimeout, updateUsingLocalStyles = defaultSettings.updateUsingLocalStyles, partialMatch = defaultSettings.partialMatch, texterPrefix = defaultSettings.texterPrefix, texterSuffix = defaultSettings.texterSuffix, griderPrefix = defaultSettings.griderPrefix, griderSuffix = defaultSettings.griderSuffix, fillerPrefix = defaultSettings.fillerPrefix, fillerSuffix = defaultSettings.fillerSuffix, strokeerPrefix = defaultSettings.strokeerPrefix, strokeerSuffix = defaultSettings.strokeerSuffix, effecterPrefix = defaultSettings.effecterPrefix, effecterSuffix = defaultSettings.effecterSuffix, } = options;
            this.addPrevToDescription = addPrevToDescription;
            this.framesPerSection = framesPerSection;
            this.textsPerSection = textsPerSection;
            this.notificationTimeout = notificationTimeout;
            this.updateUsingLocalStyles = updateUsingLocalStyles;
            this.partialMatch = partialMatch;
            this.texter = new Styler({
                name: 'texter',
                styleType: 'text',
                styleProps: [
                    'fontName',
                    'fontSize',
                    'letterSpacing',
                    'lineHeight',
                    'paragraphIndent',
                    'paragraphSpacing',
                    'textCase',
                    'textDecoration',
                ],
                prefix: texterPrefix,
                suffix: texterSuffix,
            });
            this.grider = new Styler({
                name: 'grider',
                styleType: 'grid',
                styleProps: ['layoutGrids'],
                prefix: griderPrefix,
                suffix: griderSuffix,
            });
            this.filler = new Styler({
                name: 'filler',
                styleType: 'paint',
                styleProps: ['paints'],
                layerProps: ['fills'],
                layerPropType: 'fill',
                prefix: fillerPrefix,
                suffix: fillerSuffix,
            });
            this.strokeer = new Styler({
                name: 'strokeer',
                styleType: 'paint',
                styleProps: ['paints'],
                layerProps: ['strokes'],
                layerPropType: 'stroke',
                prefix: strokeerPrefix,
                suffix: strokeerSuffix,
            });
            this.effecter = new Styler({
                name: 'effecter',
                styleType: 'effect',
                styleProps: ['effects'],
                prefix: effecterPrefix,
                suffix: effecterSuffix,
            });
            this.allStylers = [this.texter, this.filler, this.strokeer, this.effecter, this.grider];
            this.stylersWithoutTexter = [this.filler, this.strokeer, this.effecter, this.grider];
            this.texterOnly = [this.texter];
        }
    }

    const messages = (counter) => {
        return {
            applied: {
                empty: `🤔 No local style found to apply. Maybe? Renam...`,
                single: `✌️ Applied only ${counter.applied} style. He he...`,
                multiple: `✌️ Applied ${counter.applied} styles. He he...`,
            },
            detached: {
                empty: `🤔 No style was applied on any of the selected layers. Idk...`,
                single: `💔 Detached only ${counter.detached} style. Layers will miss you...`,
                multiple: `💔 Detached ${counter.detached} styles. Layers will miss you...`,
            },
            extracted: {
                empty: `😵 No local style found to extract. Ouch...`,
                single: `😺 Created only ${counter.extracted} layer. Uhuu...`,
                multiple: `😺 Created ${counter.extracted} layers. Uhuu...`,
            },
            generated: {
                empty: `😭 We do not support empty or mixed properties. Oh, Noo...`,
                single: `
      🔨 Created: ${counter.created} -
      ✨ Updated: ${counter.updated} -
      👻 Renamed: ${counter.renamed} -
      😶 No changes: ${counter.ignored}
    `,
                multiple: `
      🔨 Created: ${counter.created} -
      ✨ Updated: ${counter.updated} -
      👻 Renamed: ${counter.renamed} -
      😶 No changes: ${counter.ignored}
    `,
            },
            removed: {
                empty: `🤔 No local style was applied on any of the selected layers. Yep, it's not weird...`,
                single: `🔥 Removed only ${counter.removed} style. Rrr...`,
                multiple: `🔥 Removed ${counter.removed} styles. Rrr...`,
            },
            customize: {
                empty: '🌟 Settings were saved, but there was nothing to update.',
                single: '✅ Settings were saved and only 1 style was updated.',
                multiple: `✅ Settings were saved and ${counter.customize} style was updated.`,
            },
            layers: {
                empty: '😎 You must select at least 1 layer. Yea...',
            },
            cancelSettings: {
                empty: '🥺 Nothing was changed, everything is as before.',
            },
            clearCache: {
                empty: '🧹 Cleaned saved settings from cache.',
            },
        };
    };

    const showNofication = (counter = 0, messages, timeout = 7000) => {
        const { verySpecial = '', special = '', empty = '', single = '', multiple = '' } = messages;
        switch (counter) {
            case -2:
                figma.notify(verySpecial, { timeout });
                break;
            case -1:
                figma.notify(special, { timeout });
                break;
            case 0:
                figma.notify(empty, { timeout });
                break;
            case 1:
                figma.notify(single, { timeout });
                break;
            default:
                figma.notify(multiple, { timeout });
        }
        figma.closePlugin();
    };
    const showNotificationAtArrayEnd = (type, notificationOptions = {}) => {
        const { layerIndex = 0, layersLength = 1, stylerIndex = 0, stylersLength = 1, notificationTimeout = defaultSettings.notificationTimeout, } = notificationOptions;
        if (layerIndex === layersLength - 1 && stylerIndex === stylersLength - 1) {
            showNofication(counter[type], messages(counter)[type], notificationTimeout);
        }
    };

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation.

    Permission to use, copy, modify, and/or distribute this software for any
    purpose with or without fee is hereby granted.

    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
    REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
    AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
    INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
    LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
    OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
    PERFORMANCE OF THIS SOFTWARE.
    ***************************************************************************** */

    function __awaiter(thisArg, _arguments, P, generator) {
        function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
            function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
            function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    }

    const namesRGB = ['r', 'g', 'b'];
    function webRGBToFigmaRGB(color) {
        const rgb = {};
        namesRGB.forEach((e, i) => {
            rgb[e] = color[i] / 255;
        });
        if (color[3] !== undefined)
            rgb['a'] = color[3];
        return rgb;
    }

    const isContainer = (layer) => ['FRAME', 'COMPONENT', 'INSTANCE'].includes(layer.type);
    const isShape = (layer) => ['RECTANGLE', 'ELLIPSE', 'POLYGON', 'STAR', 'VECTOR'].includes(layer.type);
    const isText = (layer) => layer.type === 'TEXT';
    const excludeGroups = (layers) => layers.filter((layer) => isContainer(layer) || isShape(layer) || isText(layer));
    const changeColor = (layer, prop, rgba = [0, 0, 0, 1]) => {
        const color = webRGBToFigmaRGB(rgba);
        const { r, g, b, a } = color;
        const cloned = clone(layer[prop]);
        cloned[0].color = { r, g, b };
        cloned[0].opacity = a;
        return (layer[prop] = cloned);
    };
    const changeLayoutProps = (targetedFrame, options = {}) => {
        const { layoutMode = 'NONE', layoutAlign = 'MIN', counterAxisSizingMode = 'AUTO', horizontalPadding = 0, verticalPadding = 0, itemSpacing = 0, } = options;
        if (!targetedFrame) {
            return;
        }
        targetedFrame.layoutMode = layoutMode;
        targetedFrame.layoutAlign = layoutAlign;
        targetedFrame.counterAxisSizingMode = counterAxisSizingMode;
        targetedFrame.horizontalPadding = horizontalPadding;
        targetedFrame.verticalPadding = verticalPadding;
        targetedFrame.itemSpacing = itemSpacing;
        return targetedFrame;
    };
    const createTextLayer = (name = 'TextLayer', parent = figma.currentPage, options = {}) => __awaiter(void 0, void 0, void 0, function* () {
        const { color = colors.transparent, xPos = 0, yPos = xPos } = options;
        const newLayer = figma.createText();
        yield figma.loadFontAsync(newLayer.fontName);
        newLayer.name = name;
        newLayer.characters = name;
        if (color) {
            changeColor(newLayer, 'fills', color);
        }
        newLayer.x = xPos;
        newLayer.y = yPos;
        parent.appendChild(newLayer);
        return newLayer;
    });
    const createFrameLayer = (name = 'FrameLayer', parent = figma.currentPage, options = {}) => {
        const { color = colors.transparent, layoutProps = {}, size = 80, width = size, height = width, xPos = 0, yPos = xPos, cornerRadius = 12, } = options;
        const newLayer = figma.createFrame();
        newLayer.name = name;
        if (color) {
            changeColor(newLayer, 'fills', color);
        }
        newLayer.x = xPos;
        newLayer.y = yPos;
        newLayer.resize(width, height);
        newLayer.cornerRadius = cornerRadius;
        parent.appendChild(newLayer);
        changeLayoutProps(newLayer, layoutProps);
        return newLayer;
    };
    const createLayer = (name = 'Layer', parent = figma.currentPage, layerType = 'PAINT', options = {}) => __awaiter(void 0, void 0, void 0, function* () {
        const createCommand = {
            TEXT: createTextLayer,
            GRID: createFrameLayer,
            PAINT: createFrameLayer,
            EFFECT: createFrameLayer,
        };
        return yield createCommand[layerType](name, parent, options);
    });
    const ungroup = (layer) => layer.parent.parent.appendChild(layer);
    const cleanSelection = () => {
        const selection = excludeGroups(figma.currentPage.selection);
        const selectionByParent = Object.values(groupBy(selection, 'parent'));
        const layers = [];
        selectionByParent.map((group) => {
            const orderedGroup = [...group].sort((current, next) => {
                return current.parent.children.indexOf(current) - next.parent.children.indexOf(next);
            });
            layers.push(orderedGroup);
        });
        return layers.flat().reverse();
    };

    const getAllLocalStyles = () => {
        return [
            ...figma.getLocalTextStyles(),
            ...figma.getLocalGridStyles(),
            ...figma.getLocalPaintStyles(),
            ...figma.getLocalEffectStyles(),
        ];
    };
    const updateStyleNames = (currentConfig, newConfig) => {
        const { allStylers } = currentConfig;
        allStylers.map((styler) => {
            const styles = styler.getLocalStyles();
            if (isArrayEmpty(styles)) {
                return;
            }
            styles.map((style) => {
                if (style.type !== styler.styleType ||
                    checkStyleType(style, currentConfig) !== styler.layerPropType) {
                    return;
                }
                const { name } = styler;
                const newPrefix = newConfig[name].prefix;
                const newSuffix = newConfig[name].suffix;
                if (newPrefix === styler.prefix && newSuffix === styler.suffix) {
                    return;
                }
                style.name = styler.replaceAffix(style.name, newPrefix, newSuffix);
                counter.customize++;
            });
        });
    };
    const changeAllStyles = (config) => {
        const { addPrevToDescription, allStylers, notificationTimeout, texterOnly, partialMatch, updateUsingLocalStyles, } = config;
        const layers = cleanSelection();
        if (isArrayEmpty(layers)) {
            showNofication(0, messages(counter).layers, notificationTimeout);
            return;
        }
        const layersLength = layers.length;
        layers.map((layer, layerIndex) => __awaiter(void 0, void 0, void 0, function* () {
            let stylers = allStylers;
            const oldLayerName = layer.name;
            if (layer.type === 'TEXT') {
                yield figma.loadFontAsync(layer.fontName);
                if (layer.name[0] !== '+') {
                    stylers = texterOnly;
                }
                else {
                    layer.name = layer.name.slice(1);
                }
            }
            const stylersLength = stylers.length;
            stylers.map((styler, stylerIndex) => {
                const notificationOptions = {
                    layerIndex,
                    layersLength,
                    stylerIndex,
                    stylersLength,
                    notificationTimeout,
                };
                const styleIdMatch = styler.getStyleById(layer);
                const styleNameMatch = styler.getStyleByName(layer.name, partialMatch);
                if (CMD === 'generate-all-styles') {
                    styler.generateStyle(layer, {
                        styleNameMatch,
                        styleIdMatch,
                        updateUsingLocalStyles,
                        addPrevToDescription,
                    });
                    showNotificationAtArrayEnd('generated', notificationOptions);
                }
                else if (CMD === 'detach-all-styles') {
                    styler.detachStyle(layer);
                    showNotificationAtArrayEnd('detached', notificationOptions);
                }
                else if (CMD.includes('remove')) {
                    styler.removeStyle(layer, styleIdMatch);
                    showNotificationAtArrayEnd('removed', notificationOptions);
                }
                else {
                    figma.closePlugin('🤷‍♂️ This should not happen. Nothing was changed...');
                }
            });
            layer.name = oldLayerName;
        }));
    };
    const extractAllStyles = (config) => __awaiter(void 0, void 0, void 0, function* () {
        const { allStylers, framesPerSection, textsPerSection } = config;
        if (isArrayEmpty(getAllLocalStyles())) {
            return;
        }
        const horizFlow = {
            layoutProps: { layoutMode: 'HORIZONTAL', itemSpacing: 32 },
        };
        const vertFlow = {
            layoutProps: { layoutMode: 'VERTICAL', itemSpacing: 32 },
        };
        const mainContainer = createFrameLayer('main', undefined, {
            layoutProps: { layoutMode: 'HORIZONTAL', itemSpacing: 128 },
        });
        const textContainer = createFrameLayer('text', mainContainer, horizFlow);
        const miscContainer = createFrameLayer('misc', mainContainer, vertFlow);
        let createdLayers = [];
        let newSection;
        for (const styler of allStylers) {
            const styles = styler.getLocalStyles();
            if (isArrayEmpty(styles)) {
                continue;
            }
            const parentByType = styler.styleType === 'TEXT' ? textContainer : miscContainer;
            const flowByType = styler.styleType === 'TEXT' ? vertFlow : horizFlow;
            const itemsPerSection = styler.styleType === 'TEXT' ? textsPerSection : framesPerSection;
            const optionByType = styler.styleType === 'TEXT' ? { color: colors.black } : { size: 80, color: colors.white };
            yield Promise.all(styles.map((style, styleIndex) => __awaiter(void 0, void 0, void 0, function* () {
                if (style.type !== styler.styleType ||
                    checkStyleType(style, config) !== styler.layerPropType) {
                    return;
                }
                const curatedStyleName = styler.replaceAffix(style.name, '');
                let layerMatch = createdLayers.find((layer) => layer.name === curatedStyleName);
                if (!layerMatch) {
                    if (styleIndex % itemsPerSection === 0) {
                        newSection = createFrameLayer('section', parentByType, flowByType);
                    }
                    layerMatch = yield createLayer(curatedStyleName, newSection, style.type, optionByType);
                    createdLayers.push(layerMatch);
                    counter.extracted++;
                }
                styler.applyStyle(layerMatch, style);
            })));
        }
        yield new Promise((res) => setTimeout(res, 100));
        figma.group(createdLayers, figma.currentPage);
        createdLayers.map((layer) => ungroup(layer));
        figma.viewport.scrollAndZoomIntoView(createdLayers);
        mainContainer.remove();
    });
    const applyStyles = (config) => {
        const { addPrevToDescription, allStylers, notificationTimeout, texterOnly, partialMatch, updateUsingLocalStyles, } = config;
        const selectionIds = figma.currentPage.selection.map((layer) => getFlat(layer)).flat();
        const selection = selectionIds.map((id) => figma.getNodeById(id));
        if (isArrayEmpty(selection)) {
            showNofication(0, messages(counter).layers, notificationTimeout);
            return;
        }
        const selectionLength = selection.length;
        selection.map((layer, layerIndex) => __awaiter(void 0, void 0, void 0, function* () {
            let stylers = allStylers;
            const oldLayerName = layer.name;
            if (layer.type === 'TEXT') {
                yield figma.loadFontAsync(layer.fontName);
                if (layer.name[0] !== '+') {
                    stylers = texterOnly;
                }
                else {
                    layer.name = layer.name.slice(1);
                }
            }
            const stylersLength = stylers.length;
            stylers.map((styler, stylerIndex) => {
                const notificationOptions = {
                    layerIndex,
                    selectionLength,
                    stylerIndex,
                    stylersLength,
                    notificationTimeout,
                };
                const styleNameMatch = styler.getStyleByName(layer.name, partialMatch);
                const applyingStyle = styler.getLocalStyleByByExternalId(layer) || styleNameMatch;
                styler.applyStyle(layer, applyingStyle);
                showNotificationAtArrayEnd('applied', notificationOptions);
            });
            layer.name = oldLayerName;
        }));
    };

    let currentConfig;
    figma.clientStorage.getAsync(clientStorageKey).then((cachedSettings) => {
        currentConfig = new Config(cachedSettings);
        const { notificationTimeout } = currentConfig;
        switch (CMD) {
            case 'clear-cache':
                figma.clientStorage.setAsync(clientStorageKey, undefined).then(() => {
                    showNofication(0, messages(counter).clearCache, currentConfig.notificationTimeout);
                });
                break;
            case 'extract-all-styles':
                extractAllStyles(currentConfig).then(() => showNofication(counter.extracted, messages(counter).extracted, notificationTimeout));
                break;
            case 'customize-plugin':
                figma.showUI(__html__, { width: 320, height: 424 });
                figma.ui.postMessage(cachedSettings);
                figma.ui.onmessage = (msg) => {
                    if (msg.type === 'cancel-modal') {
                        showNofication(0, messages(counter).cancelSettings, notificationTimeout);
                    }
                    else if (msg.type === 'save-settings') {
                        figma.clientStorage.setAsync(clientStorageKey, msg.uiSettings).then(() => {
                            const newConfig = new Config(msg.uiSettings);
                            updateStyleNames(currentConfig, newConfig);
                            showNofication(counter.customize, messages(counter).customize, newConfig.notificationTimeout);
                            return;
                        });
                    }
                };
                break;
            case 'apply-all-styles':
                applyStyles(currentConfig);
                break;
            default:
                changeAllStyles(currentConfig);
                break;
        }
    });

}());

</script>
</body></html>